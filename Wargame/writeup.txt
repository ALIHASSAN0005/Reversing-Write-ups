The binary takes a single commandâ€‘line argument and first checks that its length is exactly nine characters before copying the hardcoded string "gssw#tpcz" into a local buffer and seeding the PRNG with srandom(1983), which makes the rand() output fully deterministic; inside a loop that runs nine times, the program calls rand(), subtracts (rand() % 5) + 1 from each character of the buffer, and compares the result with the corresponding byte of the user input, exiting on the first mismatch. To solve it, I supplied a dummy input of length nine ("AAAAAAAAA") to ensure the loop executed, then used GDB to step through each comparison, observing the correct expected value at every cmp instruction; since the comparison would normally fail and exit, I manually forced the Zero Flag to 1 after each cmp so the loop could continue through all nine iterations. By doing this, I recovered the correct expected values for each position, which were initially observed in hex at runtime and then converted to ASCII, yielding the final password "dont play".
